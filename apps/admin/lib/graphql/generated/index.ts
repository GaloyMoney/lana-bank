// this file is autogenerated by codegen
/* eslint-disable */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  AnnualRatePct: { input: any; output: any; }
  CVLPct: { input: any; output: any; }
  DisbursementIdx: { input: any; output: any; }
  Satoshis: { input: any; output: any; }
  SignedSatoshis: { input: any; output: any; }
  SignedUsdCents: { input: any; output: any; }
  Timestamp: { input: any; output: any; }
  UUID: { input: string; output: string; }
  Upload: { input: any; output: any; }
  UsdCents: { input: any; output: any; }
};

export type Account = {
  __typename?: 'Account';
  amounts: AccountAmountsByCurrency;
  id: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
};

export type AccountAmountsByCurrency = {
  __typename?: 'AccountAmountsByCurrency';
  btc: BtcAccountAmountsInPeriod;
  usd: UsdAccountAmountsInPeriod;
};

export type AccountSet = {
  __typename?: 'AccountSet';
  amounts: AccountAmountsByCurrency;
  hasSubAccounts: Scalars['Boolean']['output'];
  id: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
};

export type AccountSetAndSubAccounts = {
  __typename?: 'AccountSetAndSubAccounts';
  amounts: AccountAmountsByCurrency;
  id: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
  subAccounts: AccountSetSubAccountConnection;
};


export type AccountSetAndSubAccountsSubAccountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
};

export type AccountSetSubAccount = Account | AccountSet;

export type AccountSetSubAccountConnection = {
  __typename?: 'AccountSetSubAccountConnection';
  /** A list of edges. */
  edges: Array<AccountSetSubAccountEdge>;
  /** A list of nodes. */
  nodes: Array<AccountSetSubAccount>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AccountSetSubAccountEdge = {
  __typename?: 'AccountSetSubAccountEdge';
  /** A cursor for use in pagination */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge */
  node: AccountSetSubAccount;
};

export enum AccountStatus {
  Active = 'ACTIVE',
  Inactive = 'INACTIVE'
}

export type AuditEntry = {
  __typename?: 'AuditEntry';
  action: Scalars['String']['output'];
  authorized: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  object: Scalars['String']['output'];
  recordedAt: Scalars['Timestamp']['output'];
  subject: Subject;
};

export type AuditEntryConnection = {
  __typename?: 'AuditEntryConnection';
  /** A list of edges. */
  edges: Array<AuditEntryEdge>;
  /** A list of nodes. */
  nodes: Array<AuditEntry>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AuditEntryEdge = {
  __typename?: 'AuditEntryEdge';
  /** A cursor for use in pagination */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge */
  node: AuditEntry;
};

export type BalanceSheet = {
  __typename?: 'BalanceSheet';
  balance: AccountAmountsByCurrency;
  categories: Array<StatementCategory>;
  name: Scalars['String']['output'];
};

export type BtcAccountAmounts = {
  __typename?: 'BtcAccountAmounts';
  credit: Scalars['Satoshis']['output'];
  debit: Scalars['Satoshis']['output'];
  netCredit: Scalars['SignedSatoshis']['output'];
  netDebit: Scalars['SignedSatoshis']['output'];
};

export type BtcAccountAmountsInPeriod = {
  __typename?: 'BtcAccountAmountsInPeriod';
  amount: LayeredBtcAccountAmounts;
  closingBalance: LayeredBtcAccountAmounts;
  openingBalance: LayeredBtcAccountAmounts;
};

export type CashFlowStatement = {
  __typename?: 'CashFlowStatement';
  categories: Array<StatementCategory>;
  name: Scalars['String']['output'];
  total: AccountAmountsByCurrency;
};

export type ChartOfAccounts = {
  __typename?: 'ChartOfAccounts';
  categories: Array<StatementCategory>;
  name: Scalars['String']['output'];
};

export type Checking = {
  __typename?: 'Checking';
  pending: Scalars['UsdCents']['output'];
  settled: Scalars['UsdCents']['output'];
};

export type Collateral = {
  __typename?: 'Collateral';
  btcBalance: Scalars['Satoshis']['output'];
};

export enum CollateralAction {
  Add = 'ADD',
  Remove = 'REMOVE'
}

export type CollateralUpdated = {
  __typename?: 'CollateralUpdated';
  action: CollateralAction;
  recordedAt: Scalars['Timestamp']['output'];
  satoshis: Scalars['Satoshis']['output'];
  txId: Scalars['UUID']['output'];
};

export enum CollateralizationState {
  FullyCollateralized = 'FULLY_COLLATERALIZED',
  NoCollateral = 'NO_COLLATERAL',
  UnderLiquidationThreshold = 'UNDER_LIQUIDATION_THRESHOLD',
  UnderMarginCallThreshold = 'UNDER_MARGIN_CALL_THRESHOLD'
}

export type CollateralizationStateUpdateInput = {
  loanId: Scalars['UUID']['input'];
};

export type CollateralizationStateUpdatePayload = {
  __typename?: 'CollateralizationStateUpdatePayload';
  loan: Loan;
};

export type CollateralizationUpdated = {
  __typename?: 'CollateralizationUpdated';
  collateral: Scalars['Satoshis']['output'];
  outstandingInterest: Scalars['UsdCents']['output'];
  outstandingPrincipal: Scalars['UsdCents']['output'];
  price: Scalars['UsdCents']['output'];
  recordedAt: Scalars['Timestamp']['output'];
  state: LoanCollaterizationState;
};

export type CreditFacility = {
  __typename?: 'CreditFacility';
  approvals: Array<CreditFacilityApproval>;
  approvedAt?: Maybe<Scalars['Timestamp']['output']>;
  balance: CreditFacilityBalance;
  canBeCompleted: Scalars['Boolean']['output'];
  collateral: Scalars['Satoshis']['output'];
  collateralToMatchInitialCvl?: Maybe<Scalars['Satoshis']['output']>;
  collateralizationState: CollateralizationState;
  createdAt: Scalars['Timestamp']['output'];
  creditFacilityId: Scalars['UUID']['output'];
  creditFacilityTerms: TermValues;
  currentCvl?: Maybe<Scalars['Float']['output']>;
  customer: Customer;
  disbursements: Array<CreditFacilityDisbursement>;
  expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  facilityAmount: Scalars['UsdCents']['output'];
  id: Scalars['ID']['output'];
  status: CreditFacilityStatus;
  transactions: Array<CreditFacilityHistoryEntry>;
  userCanApprove: Scalars['Boolean']['output'];
  userCanApproveDisbursement: Scalars['Boolean']['output'];
  userCanComplete: Scalars['Boolean']['output'];
  userCanInitiateDisbursement: Scalars['Boolean']['output'];
  userCanRecordPayment: Scalars['Boolean']['output'];
  userCanUpdateCollateral: Scalars['Boolean']['output'];
};

export type CreditFacilityApproval = {
  __typename?: 'CreditFacilityApproval';
  approvedAt: Scalars['Timestamp']['output'];
  user: User;
  userId: Scalars['UUID']['output'];
};

export type CreditFacilityApproveInput = {
  creditFacilityId: Scalars['UUID']['input'];
};

export type CreditFacilityApprovePayload = {
  __typename?: 'CreditFacilityApprovePayload';
  creditFacility: CreditFacility;
};

export type CreditFacilityBalance = {
  __typename?: 'CreditFacilityBalance';
  collateral: Collateral;
  disbursed: Disbursed;
  facilityRemaining: FacilityRemaining;
  interest: Interest;
  outstanding: Outstanding;
};

export type CreditFacilityCollateralUpdateInput = {
  collateral: Scalars['Satoshis']['input'];
  creditFacilityId: Scalars['UUID']['input'];
};

export type CreditFacilityCollateralUpdatePayload = {
  __typename?: 'CreditFacilityCollateralUpdatePayload';
  creditFacility: CreditFacility;
};

export type CreditFacilityCollateralUpdated = {
  __typename?: 'CreditFacilityCollateralUpdated';
  action: CollateralAction;
  recordedAt: Scalars['Timestamp']['output'];
  satoshis: Scalars['Satoshis']['output'];
  txId: Scalars['UUID']['output'];
};

export type CreditFacilityCollateralizationUpdated = {
  __typename?: 'CreditFacilityCollateralizationUpdated';
  collateral: Scalars['Satoshis']['output'];
  outstandingDisbursement: Scalars['UsdCents']['output'];
  outstandingInterest: Scalars['UsdCents']['output'];
  price: Scalars['UsdCents']['output'];
  recordedAt: Scalars['Timestamp']['output'];
  state: CollateralizationState;
};

export type CreditFacilityCompleteInput = {
  creditFacilityId: Scalars['UUID']['input'];
};

export type CreditFacilityCompletePayload = {
  __typename?: 'CreditFacilityCompletePayload';
  creditFacility: CreditFacility;
};

export type CreditFacilityConnection = {
  __typename?: 'CreditFacilityConnection';
  /** A list of edges. */
  edges: Array<CreditFacilityEdge>;
  /** A list of nodes. */
  nodes: Array<CreditFacility>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type CreditFacilityCreateInput = {
  customerId: Scalars['UUID']['input'];
  facility: Scalars['UsdCents']['input'];
  terms: TermsInput;
};

export type CreditFacilityCreatePayload = {
  __typename?: 'CreditFacilityCreatePayload';
  creditFacility: CreditFacility;
};

export type CreditFacilityDisbursement = {
  __typename?: 'CreditFacilityDisbursement';
  amount: Scalars['UsdCents']['output'];
  approvals: Array<DisbursementApproval>;
  createdAt: Scalars['Timestamp']['output'];
  id: Scalars['ID']['output'];
  index: Scalars['DisbursementIdx']['output'];
  status: DisbursementStatus;
};

export type CreditFacilityDisbursementApproveInput = {
  creditFacilityId: Scalars['UUID']['input'];
  disbursementIdx: Scalars['DisbursementIdx']['input'];
};

export type CreditFacilityDisbursementApprovePayload = {
  __typename?: 'CreditFacilityDisbursementApprovePayload';
  disbursement: CreditFacilityDisbursement;
};

export type CreditFacilityDisbursementExecuted = {
  __typename?: 'CreditFacilityDisbursementExecuted';
  cents: Scalars['UsdCents']['output'];
  recordedAt: Scalars['Timestamp']['output'];
  txId: Scalars['UUID']['output'];
};

export type CreditFacilityDisbursementInitiateInput = {
  amount: Scalars['UsdCents']['input'];
  creditFacilityId: Scalars['UUID']['input'];
};

export type CreditFacilityDisbursementInitiatePayload = {
  __typename?: 'CreditFacilityDisbursementInitiatePayload';
  disbursement: CreditFacilityDisbursement;
};

/** An edge in a connection. */
export type CreditFacilityEdge = {
  __typename?: 'CreditFacilityEdge';
  /** A cursor for use in pagination */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge */
  node: CreditFacility;
};

export type CreditFacilityHistoryEntry = CreditFacilityCollateralUpdated | CreditFacilityCollateralizationUpdated | CreditFacilityDisbursementExecuted | CreditFacilityIncrementalPayment | CreditFacilityOrigination;

export type CreditFacilityIncrementalPayment = {
  __typename?: 'CreditFacilityIncrementalPayment';
  cents: Scalars['UsdCents']['output'];
  recordedAt: Scalars['Timestamp']['output'];
  txId: Scalars['UUID']['output'];
};

export type CreditFacilityOrigination = {
  __typename?: 'CreditFacilityOrigination';
  cents: Scalars['UsdCents']['output'];
  recordedAt: Scalars['Timestamp']['output'];
  txId: Scalars['UUID']['output'];
};

export type CreditFacilityPartialPaymentInput = {
  amount: Scalars['UsdCents']['input'];
  creditFacilityId: Scalars['UUID']['input'];
};

export type CreditFacilityPartialPaymentPayload = {
  __typename?: 'CreditFacilityPartialPaymentPayload';
  creditFacility: CreditFacility;
};

export enum CreditFacilityStatus {
  Active = 'ACTIVE',
  Closed = 'CLOSED',
  New = 'NEW'
}

export type Customer = {
  __typename?: 'Customer';
  applicantId?: Maybe<Scalars['String']['output']>;
  audit: Array<AuditEntry>;
  balance: CustomerBalance;
  creditFacilities: Array<CreditFacility>;
  customerId: Scalars['UUID']['output'];
  deposits: Array<Deposit>;
  documents: Array<Document>;
  email: Scalars['String']['output'];
  level: KycLevel;
  loans: Array<Loan>;
  status: AccountStatus;
  telegramId: Scalars['String']['output'];
  transactions: Array<Transaction>;
  userCanCreateCreditFacility: Scalars['Boolean']['output'];
  userCanCreateLoan: Scalars['Boolean']['output'];
  userCanInitiateWithdrawal: Scalars['Boolean']['output'];
  userCanRecordDeposit: Scalars['Boolean']['output'];
  withdrawals: Array<Withdrawal>;
};

export type CustomerBalance = {
  __typename?: 'CustomerBalance';
  checking: Checking;
};

export type CustomerConnection = {
  __typename?: 'CustomerConnection';
  /** A list of edges. */
  edges: Array<CustomerEdge>;
  /** A list of nodes. */
  nodes: Array<Customer>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type CustomerCreateInput = {
  email: Scalars['String']['input'];
  telegramId: Scalars['String']['input'];
};

export type CustomerCreatePayload = {
  __typename?: 'CustomerCreatePayload';
  customer: Customer;
};

/** An edge in a connection. */
export type CustomerEdge = {
  __typename?: 'CustomerEdge';
  /** A cursor for use in pagination */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge */
  node: Customer;
};

export type CustomerUpdateInput = {
  customerId: Scalars['UUID']['input'];
  telegramId: Scalars['String']['input'];
};

export type CustomerUpdatePayload = {
  __typename?: 'CustomerUpdatePayload';
  customer: Customer;
};

export type Deposit = {
  __typename?: 'Deposit';
  amount: Scalars['UsdCents']['output'];
  createdAt: Scalars['Timestamp']['output'];
  customer?: Maybe<Customer>;
  customerId: Scalars['UUID']['output'];
  depositId: Scalars['UUID']['output'];
  reference: Scalars['String']['output'];
};

export type DepositConnection = {
  __typename?: 'DepositConnection';
  /** A list of edges. */
  edges: Array<DepositEdge>;
  /** A list of nodes. */
  nodes: Array<Deposit>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DepositEdge = {
  __typename?: 'DepositEdge';
  /** A cursor for use in pagination */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge */
  node: Deposit;
};

export type DepositRecordInput = {
  amount: Scalars['UsdCents']['input'];
  customerId: Scalars['UUID']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
};

export type DepositRecordPayload = {
  __typename?: 'DepositRecordPayload';
  deposit: Deposit;
};

export type Disbursed = {
  __typename?: 'Disbursed';
  outstanding: Outstanding;
  total: Total;
};

export type DisbursementApproval = {
  __typename?: 'DisbursementApproval';
  approvedAt: Scalars['Timestamp']['output'];
  user: User;
  userId: Scalars['UUID']['output'];
};

export enum DisbursementStatus {
  Approved = 'APPROVED',
  New = 'NEW'
}

export type Document = {
  __typename?: 'Document';
  customerId: Scalars['UUID']['output'];
  filename: Scalars['String']['output'];
  id: Scalars['UUID']['output'];
  status: DocumentStatus;
};

export type DocumentArchiveInput = {
  documentId: Scalars['UUID']['input'];
};

export type DocumentArchivePayload = {
  __typename?: 'DocumentArchivePayload';
  document: Document;
};

export type DocumentCreateInput = {
  customerId: Scalars['UUID']['input'];
  file: Scalars['Upload']['input'];
};

export type DocumentCreatePayload = {
  __typename?: 'DocumentCreatePayload';
  document: Document;
};

export type DocumentDeleteInput = {
  documentId: Scalars['UUID']['input'];
};

export type DocumentDeletePayload = {
  __typename?: 'DocumentDeletePayload';
  deletedDocumentId: Scalars['UUID']['output'];
};

export type DocumentDownloadLinksGenerateInput = {
  documentId: Scalars['UUID']['input'];
};

export type DocumentDownloadLinksGeneratePayload = {
  __typename?: 'DocumentDownloadLinksGeneratePayload';
  documentId: Scalars['UUID']['output'];
  link: Scalars['String']['output'];
};

export enum DocumentStatus {
  Active = 'ACTIVE',
  Archived = 'ARCHIVED'
}

export type Duration = {
  __typename?: 'Duration';
  period: Period;
  units: Scalars['Int']['output'];
};

export type DurationInput = {
  period: Period;
  units: Scalars['Int']['input'];
};

export type FacilityRemaining = {
  __typename?: 'FacilityRemaining';
  usdBalance: Scalars['UsdCents']['output'];
};

export type IncrementalPayment = {
  __typename?: 'IncrementalPayment';
  cents: Scalars['UsdCents']['output'];
  recordedAt: Scalars['Timestamp']['output'];
  txId: Scalars['UUID']['output'];
};

export type Interest = {
  __typename?: 'Interest';
  outstanding: Outstanding;
  total: Total;
};

export type InterestAccrued = {
  __typename?: 'InterestAccrued';
  cents: Scalars['UsdCents']['output'];
  recordedAt: Scalars['Timestamp']['output'];
  txId: Scalars['UUID']['output'];
};

export type InterestIncome = {
  __typename?: 'InterestIncome';
  usdBalance: Scalars['UsdCents']['output'];
};

export enum InterestInterval {
  EndOfDay = 'END_OF_DAY',
  EndOfMonth = 'END_OF_MONTH'
}

export enum KycLevel {
  One = 'ONE',
  Two = 'TWO',
  Zero = 'ZERO'
}

export type LayeredBtcAccountAmounts = {
  __typename?: 'LayeredBtcAccountAmounts';
  all: BtcAccountAmounts;
  encumbrance: BtcAccountAmounts;
  pending: BtcAccountAmounts;
  settled: BtcAccountAmounts;
};

export type LayeredUsdAccountAmounts = {
  __typename?: 'LayeredUsdAccountAmounts';
  all: UsdAccountAmounts;
  encumbrance: UsdAccountAmounts;
  pending: UsdAccountAmounts;
  settled: UsdAccountAmounts;
};

export type Loan = {
  __typename?: 'Loan';
  approvals: Array<LoanApproval>;
  approvedAt?: Maybe<Scalars['Timestamp']['output']>;
  balance: LoanBalance;
  collateral: Scalars['Satoshis']['output'];
  collateralToMatchInitialCvl?: Maybe<Scalars['Satoshis']['output']>;
  collateralizationState: LoanCollaterizationState;
  createdAt: Scalars['Timestamp']['output'];
  currentCvl?: Maybe<Scalars['Float']['output']>;
  customer: Customer;
  expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  id: Scalars['ID']['output'];
  loanId: Scalars['UUID']['output'];
  loanTerms: TermValues;
  principal: Scalars['UsdCents']['output'];
  repaymentPlan: Array<LoanRepaymentInPlan>;
  status: LoanStatus;
  transactions: Array<LoanHistoryEntry>;
  userCanApprove: Scalars['Boolean']['output'];
  userCanRecordPaymentOrCompleteLoan: Scalars['Boolean']['output'];
  userCanUpdateCollateral: Scalars['Boolean']['output'];
  userCanUpdateCollateralizationState: Scalars['Boolean']['output'];
};

export type LoanApproval = {
  __typename?: 'LoanApproval';
  approvedAt: Scalars['Timestamp']['output'];
  user: User;
  userId: Scalars['UUID']['output'];
};

export type LoanApproveInput = {
  loanId: Scalars['UUID']['input'];
};

export type LoanApprovePayload = {
  __typename?: 'LoanApprovePayload';
  loan: Loan;
};

export type LoanBalance = {
  __typename?: 'LoanBalance';
  collateral: Collateral;
  interestIncurred: InterestIncome;
  outstanding: Outstanding;
};

export type LoanCollateralUpdateInput = {
  collateral: Scalars['Satoshis']['input'];
  loanId: Scalars['UUID']['input'];
};

export type LoanCollateralUpdatePayload = {
  __typename?: 'LoanCollateralUpdatePayload';
  loan: Loan;
};

export enum LoanCollaterizationState {
  FullyCollateralized = 'FULLY_COLLATERALIZED',
  NoCollateral = 'NO_COLLATERAL',
  UnderLiquidationThreshold = 'UNDER_LIQUIDATION_THRESHOLD',
  UnderMarginCallThreshold = 'UNDER_MARGIN_CALL_THRESHOLD'
}

export type LoanConnection = {
  __typename?: 'LoanConnection';
  /** A list of edges. */
  edges: Array<LoanEdge>;
  /** A list of nodes. */
  nodes: Array<Loan>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type LoanCreateInput = {
  customerId: Scalars['UUID']['input'];
  desiredPrincipal: Scalars['UsdCents']['input'];
  loanTerms: TermsInput;
};

export type LoanCreatePayload = {
  __typename?: 'LoanCreatePayload';
  loan: Loan;
};

/** An edge in a connection. */
export type LoanEdge = {
  __typename?: 'LoanEdge';
  /** A cursor for use in pagination */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge */
  node: Loan;
};

export type LoanHistoryEntry = CollateralUpdated | CollateralizationUpdated | IncrementalPayment | InterestAccrued | LoanOrigination;

export type LoanOrigination = {
  __typename?: 'LoanOrigination';
  cents: Scalars['UsdCents']['output'];
  recordedAt: Scalars['Timestamp']['output'];
  txId: Scalars['UUID']['output'];
};

export type LoanPartialPaymentInput = {
  amount: Scalars['UsdCents']['input'];
  loanId: Scalars['UUID']['input'];
};

export type LoanPartialPaymentPayload = {
  __typename?: 'LoanPartialPaymentPayload';
  loan: Loan;
};

export type LoanRepaymentInPlan = {
  __typename?: 'LoanRepaymentInPlan';
  accrualAt: Scalars['Timestamp']['output'];
  dueAt: Scalars['Timestamp']['output'];
  initial: Scalars['UsdCents']['output'];
  outstanding: Scalars['UsdCents']['output'];
  repaymentType: LoanRepaymentType;
  status: LoanRepaymentStatus;
};

export enum LoanRepaymentStatus {
  Due = 'DUE',
  Overdue = 'OVERDUE',
  Paid = 'PAID',
  Upcoming = 'UPCOMING'
}

export enum LoanRepaymentType {
  Interest = 'INTEREST',
  Principal = 'PRINCIPAL'
}

export enum LoanStatus {
  Active = 'ACTIVE',
  Closed = 'CLOSED',
  New = 'NEW'
}

export type Mutation = {
  __typename?: 'Mutation';
  collateralizationStateUpdate: CollateralizationStateUpdatePayload;
  creditFacilityApprove: CreditFacilityApprovePayload;
  creditFacilityCollateralUpdate: CreditFacilityCollateralUpdatePayload;
  creditFacilityComplete: CreditFacilityCompletePayload;
  creditFacilityCreate: CreditFacilityCreatePayload;
  creditFacilityDisbursementApprove: CreditFacilityDisbursementApprovePayload;
  creditFacilityDisbursementInitiate: CreditFacilityDisbursementInitiatePayload;
  creditFacilityPartialPayment: CreditFacilityPartialPaymentPayload;
  customerCreate: CustomerCreatePayload;
  customerDocumentAttach: DocumentCreatePayload;
  customerUpdate: CustomerUpdatePayload;
  depositRecord: DepositRecordPayload;
  documentArchive: DocumentArchivePayload;
  documentDelete: DocumentDeletePayload;
  documentDownloadLinkGenerate: DocumentDownloadLinksGeneratePayload;
  loanApprove: LoanApprovePayload;
  loanCollateralUpdate: LoanCollateralUpdatePayload;
  loanCreate: LoanCreatePayload;
  loanPartialPayment: LoanPartialPaymentPayload;
  reportCreate: ReportCreatePayload;
  reportDownloadLinksGenerate: ReportDownloadLinksGeneratePayload;
  shareholderEquityAdd: SuccessPayload;
  sumsubPermalinkCreate: SumsubPermalinkCreatePayload;
  termsTemplateCreate: TermsTemplateCreatePayload;
  termsTemplateUpdate: TermsTemplateUpdatePayload;
  userAssignRole: UserAssignRolePayload;
  userCreate: UserCreatePayload;
  userRevokeRole: UserRevokeRolePayload;
  withdrawalCancel: WithdrawalCancelPayload;
  withdrawalConfirm: WithdrawalConfirmPayload;
  withdrawalInitiate: WithdrawalInitiatePayload;
};


export type MutationCollateralizationStateUpdateArgs = {
  input: CollateralizationStateUpdateInput;
};


export type MutationCreditFacilityApproveArgs = {
  input: CreditFacilityApproveInput;
};


export type MutationCreditFacilityCollateralUpdateArgs = {
  input: CreditFacilityCollateralUpdateInput;
};


export type MutationCreditFacilityCompleteArgs = {
  input: CreditFacilityCompleteInput;
};


export type MutationCreditFacilityCreateArgs = {
  input: CreditFacilityCreateInput;
};


export type MutationCreditFacilityDisbursementApproveArgs = {
  input: CreditFacilityDisbursementApproveInput;
};


export type MutationCreditFacilityDisbursementInitiateArgs = {
  input: CreditFacilityDisbursementInitiateInput;
};


export type MutationCreditFacilityPartialPaymentArgs = {
  input: CreditFacilityPartialPaymentInput;
};


export type MutationCustomerCreateArgs = {
  input: CustomerCreateInput;
};


export type MutationCustomerDocumentAttachArgs = {
  input: DocumentCreateInput;
};


export type MutationCustomerUpdateArgs = {
  input: CustomerUpdateInput;
};


export type MutationDepositRecordArgs = {
  input: DepositRecordInput;
};


export type MutationDocumentArchiveArgs = {
  input: DocumentArchiveInput;
};


export type MutationDocumentDeleteArgs = {
  input: DocumentDeleteInput;
};


export type MutationDocumentDownloadLinkGenerateArgs = {
  input: DocumentDownloadLinksGenerateInput;
};


export type MutationLoanApproveArgs = {
  input: LoanApproveInput;
};


export type MutationLoanCollateralUpdateArgs = {
  input: LoanCollateralUpdateInput;
};


export type MutationLoanCreateArgs = {
  input: LoanCreateInput;
};


export type MutationLoanPartialPaymentArgs = {
  input: LoanPartialPaymentInput;
};


export type MutationReportDownloadLinksGenerateArgs = {
  input: ReportDownloadLinksGenerateInput;
};


export type MutationShareholderEquityAddArgs = {
  input: ShareholderEquityAddInput;
};


export type MutationSumsubPermalinkCreateArgs = {
  input: SumsubPermalinkCreateInput;
};


export type MutationTermsTemplateCreateArgs = {
  input: TermsTemplateCreateInput;
};


export type MutationTermsTemplateUpdateArgs = {
  input: TermsTemplateUpdateInput;
};


export type MutationUserAssignRoleArgs = {
  input: UserAssignRoleInput;
};


export type MutationUserCreateArgs = {
  input: UserCreateInput;
};


export type MutationUserRevokeRoleArgs = {
  input: UserRevokeRoleInput;
};


export type MutationWithdrawalCancelArgs = {
  input: WithdrawalCancelInput;
};


export type MutationWithdrawalConfirmArgs = {
  input: WithdrawalConfirmInput;
};


export type MutationWithdrawalInitiateArgs = {
  input: WithdrawalInitiateInput;
};

export type Outstanding = {
  __typename?: 'Outstanding';
  usdBalance: Scalars['UsdCents']['output'];
};

/** Information about pagination in a connection */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']['output']>;
};

export enum Period {
  Months = 'MONTHS'
}

export type ProfitAndLossStatement = {
  __typename?: 'ProfitAndLossStatement';
  categories: Array<StatementCategory>;
  name: Scalars['String']['output'];
  net: AccountAmountsByCurrency;
};

export type Query = {
  __typename?: 'Query';
  accountSet?: Maybe<AccountSetAndSubAccounts>;
  audit: AuditEntryConnection;
  balanceSheet?: Maybe<BalanceSheet>;
  cashFlowStatement?: Maybe<CashFlowStatement>;
  chartOfAccounts?: Maybe<ChartOfAccounts>;
  creditFacilities: CreditFacilityConnection;
  creditFacility?: Maybe<CreditFacility>;
  customer?: Maybe<Customer>;
  customerByEmail?: Maybe<Customer>;
  customers: CustomerConnection;
  deposit?: Maybe<Deposit>;
  deposits: DepositConnection;
  document: Document;
  loan?: Maybe<Loan>;
  loans: LoanConnection;
  me: User;
  offBalanceSheetChartOfAccounts?: Maybe<ChartOfAccounts>;
  offBalanceSheetTrialBalance?: Maybe<TrialBalance>;
  profitAndLossStatement?: Maybe<ProfitAndLossStatement>;
  realtimePrice: RealtimePrice;
  report?: Maybe<Report>;
  reports: Array<Report>;
  termsTemplate?: Maybe<TermsTemplate>;
  termsTemplates: Array<TermsTemplate>;
  trialBalance?: Maybe<TrialBalance>;
  user?: Maybe<User>;
  users: Array<User>;
  withdrawal?: Maybe<Withdrawal>;
  withdrawals: WithdrawalConnection;
};


export type QueryAccountSetArgs = {
  accountSetId: Scalars['UUID']['input'];
  from: Scalars['Timestamp']['input'];
  until?: InputMaybe<Scalars['Timestamp']['input']>;
};


export type QueryAuditArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
};


export type QueryBalanceSheetArgs = {
  from: Scalars['Timestamp']['input'];
  until?: InputMaybe<Scalars['Timestamp']['input']>;
};


export type QueryCashFlowStatementArgs = {
  from: Scalars['Timestamp']['input'];
  until?: InputMaybe<Scalars['Timestamp']['input']>;
};


export type QueryCreditFacilitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
};


export type QueryCreditFacilityArgs = {
  id: Scalars['UUID']['input'];
};


export type QueryCustomerArgs = {
  id: Scalars['UUID']['input'];
};


export type QueryCustomerByEmailArgs = {
  email: Scalars['String']['input'];
};


export type QueryCustomersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
};


export type QueryDepositArgs = {
  id: Scalars['UUID']['input'];
};


export type QueryDepositsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
};


export type QueryDocumentArgs = {
  id: Scalars['UUID']['input'];
};


export type QueryLoanArgs = {
  id: Scalars['UUID']['input'];
};


export type QueryLoansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
};


export type QueryOffBalanceSheetTrialBalanceArgs = {
  from: Scalars['Timestamp']['input'];
  until?: InputMaybe<Scalars['Timestamp']['input']>;
};


export type QueryProfitAndLossStatementArgs = {
  from: Scalars['Timestamp']['input'];
  until?: InputMaybe<Scalars['Timestamp']['input']>;
};


export type QueryReportArgs = {
  id: Scalars['UUID']['input'];
};


export type QueryTermsTemplateArgs = {
  id: Scalars['UUID']['input'];
};


export type QueryTrialBalanceArgs = {
  from: Scalars['Timestamp']['input'];
  until?: InputMaybe<Scalars['Timestamp']['input']>;
};


export type QueryUserArgs = {
  id: Scalars['UUID']['input'];
};


export type QueryWithdrawalArgs = {
  id: Scalars['UUID']['input'];
};


export type QueryWithdrawalsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
};

export type RealtimePrice = {
  __typename?: 'RealtimePrice';
  usdCentsPerBtc: Scalars['UsdCents']['output'];
};

export type Report = {
  __typename?: 'Report';
  createdAt: Scalars['Timestamp']['output'];
  lastError?: Maybe<Scalars['String']['output']>;
  progress: ReportProgress;
  reportId: Scalars['UUID']['output'];
};

export type ReportCreatePayload = {
  __typename?: 'ReportCreatePayload';
  report: Report;
};

export type ReportDownloadLink = {
  __typename?: 'ReportDownloadLink';
  reportName: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type ReportDownloadLinksGenerateInput = {
  reportId: Scalars['UUID']['input'];
};

export type ReportDownloadLinksGeneratePayload = {
  __typename?: 'ReportDownloadLinksGeneratePayload';
  links: Array<ReportDownloadLink>;
  reportId: Scalars['UUID']['output'];
};

export enum ReportProgress {
  Complete = 'COMPLETE',
  Running = 'RUNNING'
}

export enum Role {
  Accountant = 'ACCOUNTANT',
  Admin = 'ADMIN',
  BankManager = 'BANK_MANAGER',
  Superuser = 'SUPERUSER'
}

export type ShareholderEquityAddInput = {
  amount: Scalars['UsdCents']['input'];
  reference: Scalars['String']['input'];
};

export type StatementCategory = {
  __typename?: 'StatementCategory';
  accounts: Array<AccountSetSubAccount>;
  amounts: AccountAmountsByCurrency;
  name: Scalars['String']['output'];
};

export type Subject = Customer | System | User;

export type SuccessPayload = {
  __typename?: 'SuccessPayload';
  success: Scalars['Boolean']['output'];
};

export type SumsubPermalinkCreateInput = {
  customerId: Scalars['UUID']['input'];
};

export type SumsubPermalinkCreatePayload = {
  __typename?: 'SumsubPermalinkCreatePayload';
  url: Scalars['String']['output'];
};

export type System = {
  __typename?: 'System';
  name: Scalars['String']['output'];
};

export type TermValues = {
  __typename?: 'TermValues';
  accrualInterval: InterestInterval;
  annualRate: Scalars['AnnualRatePct']['output'];
  duration: Duration;
  incurrenceInterval: InterestInterval;
  initialCvl: Scalars['CVLPct']['output'];
  liquidationCvl: Scalars['CVLPct']['output'];
  marginCallCvl: Scalars['CVLPct']['output'];
};

export type TermsInput = {
  accrualInterval: InterestInterval;
  annualRate: Scalars['AnnualRatePct']['input'];
  duration: DurationInput;
  incurrenceInterval: InterestInterval;
  initialCvl: Scalars['CVLPct']['input'];
  liquidationCvl: Scalars['CVLPct']['input'];
  marginCallCvl: Scalars['CVLPct']['input'];
};

export type TermsTemplate = {
  __typename?: 'TermsTemplate';
  createdAt: Scalars['Timestamp']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  termsId: Scalars['UUID']['output'];
  values: TermValues;
};

export type TermsTemplateCreateInput = {
  accrualInterval: InterestInterval;
  annualRate: Scalars['AnnualRatePct']['input'];
  duration: DurationInput;
  incurrenceInterval: InterestInterval;
  initialCvl: Scalars['CVLPct']['input'];
  liquidationCvl: Scalars['CVLPct']['input'];
  marginCallCvl: Scalars['CVLPct']['input'];
  name: Scalars['String']['input'];
};

export type TermsTemplateCreatePayload = {
  __typename?: 'TermsTemplateCreatePayload';
  termsTemplate: TermsTemplate;
};

export type TermsTemplateUpdateInput = {
  accrualInterval: InterestInterval;
  annualRate: Scalars['AnnualRatePct']['input'];
  duration: DurationInput;
  id: Scalars['UUID']['input'];
  incurrenceInterval: InterestInterval;
  initialCvl: Scalars['CVLPct']['input'];
  liquidationCvl: Scalars['CVLPct']['input'];
  marginCallCvl: Scalars['CVLPct']['input'];
};

export type TermsTemplateUpdatePayload = {
  __typename?: 'TermsTemplateUpdatePayload';
  termsTemplate: TermsTemplate;
};

export type Total = {
  __typename?: 'Total';
  usdBalance: Scalars['UsdCents']['output'];
};

export type Transaction = Deposit | Withdrawal;

export type TrialBalance = {
  __typename?: 'TrialBalance';
  name: Scalars['String']['output'];
  subAccounts: Array<AccountSetSubAccount>;
  total: AccountAmountsByCurrency;
};

export type UsdAccountAmounts = {
  __typename?: 'UsdAccountAmounts';
  credit: Scalars['UsdCents']['output'];
  debit: Scalars['UsdCents']['output'];
  netCredit: Scalars['SignedUsdCents']['output'];
  netDebit: Scalars['SignedUsdCents']['output'];
};

export type UsdAccountAmountsInPeriod = {
  __typename?: 'UsdAccountAmountsInPeriod';
  amount: LayeredUsdAccountAmounts;
  closingBalance: LayeredUsdAccountAmounts;
  openingBalance: LayeredUsdAccountAmounts;
};

export type User = {
  __typename?: 'User';
  canAssignRoleToUser: Scalars['Boolean']['output'];
  canCreateCustomer: Scalars['Boolean']['output'];
  canCreateTermsTemplate: Scalars['Boolean']['output'];
  canCreateUser: Scalars['Boolean']['output'];
  canRevokeRoleFromUser: Scalars['Boolean']['output'];
  canUpdateTermsTemplate: Scalars['Boolean']['output'];
  email: Scalars['String']['output'];
  roles: Array<Role>;
  userId: Scalars['UUID']['output'];
  visibleNavigationItems: VisibleNavigationItems;
};

export type UserAssignRoleInput = {
  id: Scalars['UUID']['input'];
  role: Role;
};

export type UserAssignRolePayload = {
  __typename?: 'UserAssignRolePayload';
  user: User;
};

export type UserCreateInput = {
  email: Scalars['String']['input'];
};

export type UserCreatePayload = {
  __typename?: 'UserCreatePayload';
  user: User;
};

export type UserRevokeRoleInput = {
  id: Scalars['UUID']['input'];
  role: Role;
};

export type UserRevokeRolePayload = {
  __typename?: 'UserRevokeRolePayload';
  user: User;
};

export type VisibleNavigationItems = {
  __typename?: 'VisibleNavigationItems';
  audit: Scalars['Boolean']['output'];
  creditFacilities: Scalars['Boolean']['output'];
  customer: Scalars['Boolean']['output'];
  deposit: Scalars['Boolean']['output'];
  financials: Scalars['Boolean']['output'];
  loan: Scalars['Boolean']['output'];
  term: Scalars['Boolean']['output'];
  user: Scalars['Boolean']['output'];
  withdraw: Scalars['Boolean']['output'];
};

export type Withdrawal = {
  __typename?: 'Withdrawal';
  amount: Scalars['UsdCents']['output'];
  createdAt: Scalars['Timestamp']['output'];
  customer?: Maybe<Customer>;
  customerId: Scalars['UUID']['output'];
  reference: Scalars['String']['output'];
  status: WithdrawalStatus;
  userCanCancel: Scalars['Boolean']['output'];
  userCanConfirm: Scalars['Boolean']['output'];
  withdrawalId: Scalars['UUID']['output'];
};

export type WithdrawalCancelInput = {
  withdrawalId: Scalars['UUID']['input'];
};

export type WithdrawalCancelPayload = {
  __typename?: 'WithdrawalCancelPayload';
  withdrawal: Withdrawal;
};

export type WithdrawalConfirmInput = {
  withdrawalId: Scalars['UUID']['input'];
};

export type WithdrawalConfirmPayload = {
  __typename?: 'WithdrawalConfirmPayload';
  withdrawal: Withdrawal;
};

export type WithdrawalConnection = {
  __typename?: 'WithdrawalConnection';
  /** A list of edges. */
  edges: Array<WithdrawalEdge>;
  /** A list of nodes. */
  nodes: Array<Withdrawal>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type WithdrawalEdge = {
  __typename?: 'WithdrawalEdge';
  /** A cursor for use in pagination */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge */
  node: Withdrawal;
};

export type WithdrawalInitiateInput = {
  amount: Scalars['UsdCents']['input'];
  customerId: Scalars['UUID']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
};

export type WithdrawalInitiatePayload = {
  __typename?: 'WithdrawalInitiatePayload';
  withdrawal: Withdrawal;
};

export enum WithdrawalStatus {
  Cancelled = 'CANCELLED',
  Confirmed = 'CONFIRMED',
  Initiated = 'INITIATED'
}

export type MeQueryVariables = Exact<{ [key: string]: never; }>;


export type MeQuery = { __typename?: 'Query', me: { __typename?: 'User', userId: string, email: string, roles: Array<Role> } };


export const MeDocument = gql`
    query Me {
  me {
    userId
    email
    roles
  }
}
    `;

/**
 * __useMeQuery__
 *
 * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMeQuery({
 *   variables: {
 *   },
 * });
 */
export function useMeQuery(baseOptions?: Apollo.QueryHookOptions<MeQuery, MeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MeQuery, MeQueryVariables>(MeDocument, options);
      }
export function useMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MeQuery, MeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MeQuery, MeQueryVariables>(MeDocument, options);
        }
export type MeQueryHookResult = ReturnType<typeof useMeQuery>;
export type MeLazyQueryHookResult = ReturnType<typeof useMeLazyQuery>;
export type MeQueryResult = Apollo.QueryResult<MeQuery, MeQueryVariables>;