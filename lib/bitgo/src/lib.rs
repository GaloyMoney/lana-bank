#![cfg_attr(feature = "fail-on-warnings", deny(warnings))]
#![cfg_attr(feature = "fail-on-warnings", deny(clippy::all))]

mod config;
mod error;
mod wire;

use bip32::XPrv;
use hmac::{Hmac, Mac as _};
use rand::{TryRngCore as _, rngs::OsRng};
use reqwest::{Client, Url, header::HeaderMap};
use serde::{Serialize, de::DeserializeOwned};
use serde_json::{Value, json};
use sha2::Sha256;

pub use config::{BitgoConfig, BitgoDirectoryConfig};
pub use error::*;
pub use wire::*;

#[derive(Debug, Clone)]
pub struct BitgoClient {
    http_client: Client,
    long_lived_token: String,
    endpoint: Url,
    passphrase: String,
    enterprise_id: String,
    is_test: bool,
    coin: String,
    webhook_url: Url,
    webhook_secret: Vec<u8>,
}

impl BitgoClient {
    pub fn try_new(
        config: BitgoConfig,
        directory_config: BitgoDirectoryConfig,
    ) -> Result<Self, BitgoError> {
        let coin = if config.bitgo_test { "tbtc4" } else { "btc" };

        let endpoint = if config.bitgo_test {
            directory_config.testing_url
        } else {
            directory_config.production_url
        };

        let webhook_url = config
            .webhook_url
            .parse()
            .map_err(|_| BitgoError::InvalidWebhookUrl)?;

        Ok(Self {
            http_client: Client::new(),
            long_lived_token: config.long_lived_token,
            endpoint,
            passphrase: config.passphrase,
            enterprise_id: config.enterprise_id,
            is_test: config.bitgo_test,
            coin: coin.to_owned(),
            webhook_url,
            webhook_secret: config.webhook_secret,
        })
    }

    pub fn is_testnet(&self) -> bool {
        self.is_test
    }

    #[tracing::instrument(name = "bitgo.validate_webhook_notification", skip(self), err)]
    pub fn validate_webhook_notification(
        &self,
        headers: &HeaderMap,
        payload: &[u8],
    ) -> Result<Notification, BitgoError> {
        let signature = headers
            .get("x-signature-sha256")
            .and_then(|v| v.to_str().ok())
            .and_then(|s| hex::decode(s).ok())
            .ok_or(BitgoError::MissingWebhookSignature)?;

        let mut mac =
            Hmac::<Sha256>::new_from_slice(&self.webhook_secret).expect("valid length of secret");
        mac.update(payload);
        mac.verify_slice(&signature)?;

        Ok(serde_json::from_slice::<Notification>(payload)?)
    }

    #[tracing::instrument(name = "bitgo.create_key", skip(self), fields(response, url), err)]
    pub async fn create_key(&self, source: KeySource) -> Result<Key, BitgoError> {
        // https://developers.bitgo.com/api/v2.key.add

        let mut seed: [u8; 32] = [0; 32];
        OsRng
            .try_fill_bytes(&mut seed)
            .expect("correctly generated bytes");

        let xprv = XPrv::new(seed).expect("correct seed length");
        let xpub = xprv.public_key();
        let encrypted_prv = if source == KeySource::Bitgo {
            None
        } else {
            Some(EncryptedPrv::encrypt_randomized(xprv, &self.passphrase))
        };

        self.post(
            self.url_with_coin("key"),
            &CreateKey {
                encrypted_prv,
                source,
                enterprise: self.enterprise_id.clone(),
                xpub,
            },
        )
        .await
    }

    #[tracing::instrument(name = "bitgo.add_wallet", skip(self), fields(response, url), err)]
    pub async fn add_wallet(&self, label: &str) -> Result<(Wallet, Value), BitgoError> {
        // https://developers.bitgo.com/api/v2.wallet.add

        let user_key = self.create_key(KeySource::User).await?;
        let backup_key = self.create_key(KeySource::Backup).await?;
        let bitgo_key = self.create_key(KeySource::Bitgo).await?;

        let response_json: Value = self
            .post(
                self.url_with_coin("wallet/add"),
                &json!({
                    "label": label,
                    "keys": &[user_key.id, backup_key.id, bitgo_key.id],
                    "enterprise": &self.enterprise_id,
                    "m": 2,
                    "n": 3
                }),
            )
            .await?;

        let wallet: Wallet = serde_json::from_value(response_json.clone())?;

        self.add_wallet_webhook(&wallet.id).await?;

        Ok((wallet, response_json))
    }

    #[tracing::instrument(
        name = "bitgo.add_wallet_webhook",
        skip(self),
        fields(self.webhook_url, response, url),
        err
    )]
    pub async fn add_wallet_webhook(&self, wallet_id: &str) -> Result<(), BitgoError> {
        // https://developers.bitgo.com/api/v2.wallet.addwebhook

        let _: Value = self
            .post(
                self.url_with_coin(&format!("wallet/{wallet_id}/webhooks")),
                &json!({
                    "type": "transfer",
                    "url": self.webhook_url
                }),
            )
            .await?;

        Ok(())
    }

    #[tracing::instrument(name = "bitgo.get_wallet", skip(self), fields(response, url), err)]
    pub async fn get_wallet(&self, id: &str) -> Result<(Wallet, Value), BitgoError> {
        // https://developers.bitgo.com/api/v2.wallet.getbyid

        let response = self.get(self.url(&format!("wallet/{id}"))).await?;
        let wallet = serde_json::from_value(response.clone())?;
        Ok((wallet, response))
    }

    #[tracing::instrument(
        name = "bitgo.get_wallet_count",
        skip(self),
        fields(response, url),
        err
    )]
    pub async fn get_wallet_count(&self) -> Result<u32, BitgoError> {
        // https://developers.bitgo.com/api/v2.wallet.count

        let response = self.get(self.url("wallets/count")).await?;
        Ok(serde_json::from_value::<GetWalletCountResponse>(response)?.count)
    }

    #[tracing::instrument(name = "bitgo.get_enterprise", skip(self), fields(response, url), err)]
    pub async fn get_enterprise(&self) -> Result<Enterprise, BitgoError> {
        // https://developers.bitgo.com/api/enterprise.getById

        let response = self
            .get(self.url(&format!("enterprise/{}", self.enterprise_id)))
            .await?;
        Ok(serde_json::from_value(response)?)
    }

    #[tracing::instrument(name = "bitgo.get_transfer", skip(self), fields(response, url), err)]
    pub async fn get_transfer(&self, id: &str, wallet_id: &str) -> Result<Transfer, BitgoError> {
        // https://developers.bitgo.com/api/v2.wallet.gettransfer

        let response = self
            .get(self.url_with_coin(&format!("wallet/{wallet_id}/transfer/{id}")))
            .await?;
        Ok(serde_json::from_value(response)?)
    }
}

impl BitgoClient {
    async fn get(&self, url: Url) -> Result<Value, BitgoError> {
        tracing::Span::current().record("url", tracing::field::display(&url));

        let request = self
            .http_client
            .get(url)
            .bearer_auth(&self.long_lived_token);

        let response: Fallible<Value> = request.send().await?.json().await?;

        tracing::Span::current().record("response", tracing::field::debug(&response));

        match response {
            Fallible::Error {
                error,
                name,
                request_id,
            } => Err(BitgoError::BitgoError {
                error,
                name,
                request_id,
            }),
            Fallible::Ok(res) => Ok(res),
        }
    }

    async fn post<S: Serialize, D: DeserializeOwned>(
        &self,
        url: Url,
        payload: &S,
    ) -> Result<D, BitgoError> {
        tracing::Span::current().record("url", tracing::field::display(&url));

        let request = self
            .http_client
            .post(url)
            .bearer_auth(&self.long_lived_token)
            .json(payload);

        let response: Fallible<Value> = request.send().await?.json().await?;

        tracing::Span::current().record("response", tracing::field::debug(&response));

        match response {
            Fallible::Error {
                error,
                name,
                request_id,
            } => Err(BitgoError::BitgoError {
                error,
                name,
                request_id,
            }),
            Fallible::Ok(res) => Ok(serde_json::from_value(res)?),
        }
    }

    fn url(&self, path: &str) -> Url {
        self.endpoint
            .join("api/v2/")
            .expect("valid URL")
            .join(path)
            .expect("valid URL")
    }

    fn url_with_coin(&self, path: &str) -> Url {
        self.endpoint
            .join(&format!("api/v2/{}/", self.coin))
            .expect("valid URL")
            .join(path)
            .expect("valid URL")
    }
}
