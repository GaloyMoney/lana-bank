use aes::Aes256;
use bip32::{Prefix, XPrv, XPub};
use ccm::{
    Ccm, KeyInit as _,
    aead::{Aead as _, generic_array::GenericArray},
    consts::{U8, U13},
};
use pbkdf2::pbkdf2_hmac_array;
use rand::{TryRngCore as _, rngs::OsRng};
use serde::{Deserialize, Serialize};
use sha2::Sha256;

use crate::BitgoError;

#[derive(Clone, Debug, Deserialize)]
#[serde(untagged)]
pub enum Notification {
    Transfer(TransferNotification),
}

#[derive(Clone, Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TransferNotification {
    pub hash: String,
    pub transfer: String,
    pub wallet: String,
    pub coin: String,
    pub state: TransferState,
    pub transfer_type: TransferType,
}

#[derive(Clone, Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Wallet {
    pub id: String,
    pub label: String,
    pub receive_address: Address,
    pub confirmed_balance: u64,
}

#[derive(Clone, Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Address {
    pub address: String,
}

#[derive(Clone, Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Transfer {
    pub wallet: String,
    pub txid: String,
    pub confirmations: u32,
    pub value: u64,
    #[serde(rename = "type")]
    pub transfer_type: TransferType,
    pub state: TransferState,
}

#[derive(Clone, Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum TransferType {
    Receive,
    Send,
}

#[derive(Clone, Debug, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "camelCase")]
pub enum TransferState {
    Confirmed,
    Failed,
    Initialized,
    PendingApproval,
    Rejected,
    Removed,
    Replaced,
    Signed,
    Unconfirmed,
}

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CreateKey {
    #[serde(serialize_with = "inlined_json::serialize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encrypted_prv: Option<EncryptedPrv>,
    pub source: KeySource,
    pub enterprise: String,
    #[serde(serialize_with = "xpub::serialize", rename = "pub")]
    pub xpub: XPub,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Key {
    pub id: String,
    #[serde(with = "xpub", rename = "pub")]
    pub xpub: XPub,
    pub source: KeySource,
    #[serde(with = "inlined_json", default)]
    pub encrypted_prv: Option<EncryptedPrv>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct EncryptedPrv {
    #[serde(with = "base64_array")]
    iv: [u8; 16],
    iter: u32,
    #[serde(with = "base64_array")]
    salt: [u8; 8],
    #[serde(with = "base64_vec")]
    ct: Vec<u8>,
    v: u32,
    ks: u32,
    ts: u32,
    mode: String,
    adata: String,
    cipher: String,
}

#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum KeySource {
    User,
    Backup,
    Bitgo,
}

type Aes256Ccm = Ccm<Aes256, U8, U13>;

impl EncryptedPrv {
    pub fn decrypt(self, passphrase: &str) -> Result<XPrv, BitgoError> {
        let key = pbkdf2_hmac_array::<Sha256, 32>(passphrase.as_bytes(), &self.salt, self.iter);
        // BitGo requires IV (nonce) to have 16 bytes, but the cipher only uses first 13 (16 is invalid)
        let nonce = GenericArray::from_slice(&self.iv[0..13]);
        let cipher = Aes256Ccm::new(&GenericArray::from(key));
        let plaintext = cipher
            .decrypt(nonce, self.ct.as_ref())
            .map_err(|e| BitgoError::DecryptXprv(e.to_string()))?;

        let xprv_str =
            String::from_utf8(plaintext).map_err(|e| BitgoError::DecryptXprv(e.to_string()))?;
        xprv_str
            .parse::<XPrv>()
            .map_err(|e| BitgoError::DecryptXprv(e.to_string()))
    }

    pub fn encrypt_randomized(xprv: XPrv, passphrase: &str) -> Self {
        const ITER: u32 = 10000;
        const KEY_SIZE: u32 = 256;
        const TAG_SIZE: u32 = 64;
        const VERSION: u32 = 1;
        const CIPHER: &str = "aes";
        const AES_MODE: &str = "ccm";

        let mut salt: [u8; 8] = [0; 8];
        OsRng
            .try_fill_bytes(&mut salt)
            .expect("correctly generated bytes");

        let key = pbkdf2_hmac_array::<Sha256, 32>(passphrase.as_bytes(), &salt, ITER);
        let cipher = Aes256Ccm::new(&GenericArray::from(key));

        // BitGo requires IV (nonce) to have 16 bytes even though the cipher only uses first 13 (16 is invalid)
        let mut nonce: [u8; 16] = [0; 16];
        OsRng
            .try_fill_bytes(&mut nonce)
            .expect("correctly generated bytes");

        let ciphertext = cipher
            .encrypt(
                GenericArray::from_slice(&nonce[0..13]),
                xprv.to_string(Prefix::XPRV).as_bytes(),
            )
            .expect("encryption succeeds");

        Self {
            iv: nonce,
            salt,
            ct: ciphertext,
            iter: ITER,
            v: VERSION,
            ks: KEY_SIZE,
            ts: TAG_SIZE,
            mode: AES_MODE.to_string(),
            adata: String::new(),
            cipher: CIPHER.to_string(),
        }
    }
}

pub mod inlined_json {

    use serde::{
        Deserialize, Deserializer, Serialize, Serializer,
        de::{DeserializeOwned, Error},
    };

    pub fn deserialize<'de, D, T: DeserializeOwned>(deserializer: D) -> Result<Option<T>, D::Error>
    where
        D: Deserializer<'de>,
    {
        match Option::<String>::deserialize(deserializer)? {
            Some(s) => {
                serde_json::from_str(&s).map_err(|_| D::Error::custom("incorrect JSON format"))
            }
            None => Ok(None),
        }
    }

    pub fn serialize<S, T: Serialize>(value: &Option<T>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match value {
            Some(v) => serializer.serialize_str(&serde_json::to_string(v).expect("encoded JSON")),
            None => serializer.serialize_none(),
        }
    }
}

pub mod base64_array {
    use base64::prelude::*;
    use serde::{Deserialize, Deserializer, Serializer, de::Error};

    pub fn deserialize<'de, D, const N: usize>(deserializer: D) -> Result<[u8; N], D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        let bytes = BASE64_STANDARD
            .decode(s)
            .map_err(|_| D::Error::custom("not base64-encoded string"))?;

        let len = bytes.len();

        bytes
            .try_into()
            .map_err(|_| D::Error::custom(format!("not {N} bytes, provided {len}")))
    }

    pub fn serialize<S, const N: usize>(value: &[u8; N], serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&BASE64_STANDARD.encode(value))
    }
}

pub mod base64_vec {
    use base64::prelude::*;
    use serde::{Deserialize, Deserializer, Serializer, de::Error};

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<u8>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        BASE64_STANDARD
            .decode(s)
            .map_err(|_| D::Error::custom("not base64-encoded string"))
    }

    pub fn serialize<S>(value: &[u8], serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&BASE64_STANDARD.encode(value))
    }
}

mod xpub {
    use std::str::FromStr;

    use bip32::{Prefix, XPub};
    use serde::{Deserialize, Deserializer, Serializer, de::Error};

    pub fn deserialize<'de, D>(deserializer: D) -> Result<XPub, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        XPub::from_str(&s).map_err(|_| D::Error::custom("not serialized xpub"))
    }

    pub fn serialize<S>(value: &XPub, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&value.to_string(Prefix::XPUB))
    }
}
