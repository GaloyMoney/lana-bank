use std::env;
use std::fs;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=build.rs");

    let metadata = cargo_metadata::MetadataCommand::new()
        .exec()
        .expect("Failed to get cargo metadata");

    let mut permissions = vec![];

    for package in &metadata.workspace_packages() {
        // Skip the macro crate to avoid picking up examples
        if package.name == "permission-sets-macro" {
            continue;
        }

        let manifest_path = &package.manifest_path;
        let package_dir = manifest_path.parent()
            .expect("Package should have a parent directory");

        let src_dir = package_dir.join("src");
        if !src_dir.as_std_path().exists() {
            continue;
        }

        let crate_name = package.name.replace('-', "_");
        scan_directory_for_permissions(src_dir.as_std_path(), &crate_name, &mut permissions);
    }

    permissions.sort_by(|a, b| a.variant_name.cmp(&b.variant_name));
    generate_permission_enum(&permissions);

    println!(
        "cargo:warning=Auto-discovered {} permission sets",
        permissions.len()
    );
}

struct Permission {
    variant_name: String,
    const_name: String,
    crate_path: String,
}

fn scan_directory_for_permissions(dir: &Path, crate_name: &str, permissions: &mut Vec<Permission>) {
    let walker = walkdir::WalkDir::new(dir)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| {
            e.path().extension().map_or(false, |ext| ext == "rs") &&
            // Skip the generated file and lib.rs to avoid circular references
            !e.path().ends_with("generated_permission_sets.rs") &&
            !e.path().ends_with("lib.rs")
        });

    for entry in walker {
        let content = fs::read_to_string(entry.path()).unwrap_or_default();
        extract_permission_sets(&content, crate_name, permissions);
    }
}

fn extract_permission_sets(content: &str, crate_name: &str, permissions: &mut Vec<Permission>) {
    // Find the start of each permission_sets! macro invocation
    let mut start = 0;
    while let Some(pos) = content[start..].find("permission_sets!") {
        start += pos;

        // Find the opening brace
        if let Some(open_brace) = content[start..].find('{') {
            let open_pos = start + open_brace + 1;

            // Find the matching closing brace
            if let Some(close_pos) = find_matching_brace(&content[open_pos..]) {
                let body = &content[open_pos..open_pos + close_pos];

                // Extract identifiers from the body
                for word in body.split(|c: char| c.is_whitespace() || c == ',') {
                    let word = word.trim();
                    if !word.is_empty() && is_valid_identifier(word) {
                        let const_name = format!(
                            "PERMISSION_SET_{}",
                            camel_to_snake(word).to_uppercase()
                        );

                        permissions.push(Permission {
                            variant_name: word.to_string(),
                            const_name,
                            crate_path: crate_name.to_string(),
                        });
                    }
                }

                start = open_pos + close_pos + 1;
            } else {
                break;
            }
        } else {
            break;
        }
    }
}

fn find_matching_brace(s: &str) -> Option<usize> {
    let mut depth = 1;
    for (i, ch) in s.chars().enumerate() {
        match ch {
            '{' => depth += 1,
            '}' => {
                depth -= 1;
                if depth == 0 {
                    return Some(i);
                }
            }
            _ => {}
        }
    }
    None
}

fn is_valid_identifier(s: &str) -> bool {
    !s.is_empty()
        && s.chars().next().unwrap().is_alphabetic()
        && s.chars().all(|c| c.is_alphanumeric() || c == '_')
}

fn camel_to_snake(s: &str) -> String {
    let mut result = String::new();
    for (i, ch) in s.chars().enumerate() {
        if ch.is_uppercase() && i > 0 {
            result.push('_');
        }
        result.push(ch.to_lowercase().next().unwrap());
    }
    result
}

fn generate_permission_enum(permissions: &[Permission]) {
    let mut code = String::new();

    // Add warning comment
    code.push_str("// DO NOT MODIFY THIS FILE MANUALLY!\n");
    code.push_str("// This file is auto-generated by build.rs from permission_sets! macro invocations.\n");
    code.push_str("// To update: modify the source permission_sets! invocations and rebuild.\n");
    code.push_str("//\n");
    code.push_str("// This file is checked into version control to:\n");
    code.push_str("// 1. Make permission set changes visible in pull requests\n");
    code.push_str("// 2. Catch breaking changes to the permission set API\n");
    code.push_str("// 3. Ensure CI fails if the generated code is out of sync\n");
    code.push_str("\n");

    code.push_str("#[derive(Clone, PartialEq, Eq, Copy, Debug, async_graphql::Enum)]\n");
    code.push_str("pub enum PermissionSetName {\n");
    for perm in permissions {
        code.push_str(&format!("    {},\n", perm.variant_name));
    }
    code.push_str("}\n\n");

    code.push_str("impl std::str::FromStr for PermissionSetName {\n");
    code.push_str("    type Err = strum::ParseError;\n\n");
    code.push_str("    fn from_str(s: &str) -> Result<Self, Self::Err> {\n");
    for perm in permissions {
        let crate_ref = if perm.crate_path == "rbac_types" {
            "crate".to_string()
        } else {
            perm.crate_path.clone()
        };
        code.push_str(&format!(
            "        if s == {}::{} {{ return Ok(Self::{}); }}\n",
            crate_ref, perm.const_name, perm.variant_name
        ));
    }
    code.push_str("        Err(strum::ParseError::VariantNotFound)\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    code.push_str("impl std::fmt::Display for PermissionSetName {\n");
    code.push_str("    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n");
    code.push_str("        let s = match self {\n");
    for perm in permissions {
        let crate_ref = if perm.crate_path == "rbac_types" {
            "crate".to_string()
        } else {
            perm.crate_path.clone()
        };
        code.push_str(&format!(
            "            Self::{} => {}::{},\n",
            perm.variant_name, crate_ref, perm.const_name
        ));
    }
    code.push_str("        };\n");
    code.push_str("        write!(f, \"{}\", s)\n");
    code.push_str("    }\n");
    code.push_str("}\n");

    // Write to OUT_DIR for compilation
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated_permission_sets.rs");
    fs::write(&dest_path, &code).unwrap();

    // Also write to src/ for version control (to track breaking changes)
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let checked_in_path = Path::new(&manifest_dir).join("src/generated_permission_sets.rs");
    fs::write(&checked_in_path, &code).unwrap();

    println!("cargo:rerun-if-changed=src/generated_permission_sets.rs");
}
