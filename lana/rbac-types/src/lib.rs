#![cfg_attr(feature = "fail-on-warnings", deny(warnings))]
#![cfg_attr(feature = "fail-on-warnings", deny(clippy::all))]

mod action;
mod audit_action;
mod audit_object;
mod object;

use tracing::Level;
use tracing_utils::ErrorSeverity;

use core_access::UserId;
use core_customer::CustomerId;

pub use action::*;
pub use audit_action::*;
pub use audit_object::*;
pub use object::*;

pub use audit::SystemActor;
pub const ROLE_NAME_ACCOUNTANT: &str = "accountant";
pub const ROLE_NAME_ADMIN: &str = "admin";
pub const ROLE_NAME_BANK_MANAGER: &str = "bank-manager";

// Auto-generated by build.rs from permission_sets_macro::permission_sets! invocations.
//
// To add a new permission set:
// 1. In your core module primitives file (e.g., core-access/src/primitives.rs):
//    permission_sets_macro::permission_sets! {
//        AccessViewer,
//        AccessWriter,
//        AccessAdmin,  // â† Add new permission
//    }
// 2. Rebuild - the build script auto-discovers it and generates everything!
include!(concat!(env!("OUT_DIR"), "/generated_permission_sets.rs"));

#[derive(Clone, Debug, strum::EnumDiscriminants)]
#[strum_discriminants(derive(strum::AsRefStr, strum::EnumString))]
#[strum_discriminants(strum(serialize_all = "kebab-case"))]
pub enum Subject {
    Customer(CustomerId),
    User(UserId),
    System(audit::SystemActor),
}

impl audit::SystemSubject for Subject {
    fn system(actor: audit::SystemActor) -> Self {
        Subject::System(actor)
    }
}

impl std::str::FromStr for Subject {
    type Err = ParseSubjectError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = s.splitn(2, ':').collect();
        if parts.len() != 2 {
            return Err(ParseSubjectError::InvalidSubjectFormat);
        }

        use SubjectDiscriminants::*;
        let res = match SubjectDiscriminants::from_str(parts[0])? {
            Customer => {
                let id: uuid::Uuid = parts[1].parse()?;
                Subject::Customer(CustomerId::from(id))
            }
            User => {
                let id: uuid::Uuid = parts[1].parse()?;
                Subject::User(UserId::from(id))
            }
            System => Subject::System(audit::SystemActor::from(parts[1].to_string())),
        };
        Ok(res)
    }
}

#[derive(thiserror::Error, Debug)]
pub enum ParseSubjectError {
    #[error("ParseSubjectError - Strum: {0}")]
    Strum(#[from] strum::ParseError),
    #[error("ParseSubjectError - Uuid: {0}")]
    Uuid(#[from] uuid::Error),
    #[error("ParseSubjectError - InvalidSubjectFormat")]
    InvalidSubjectFormat,
}

impl ErrorSeverity for ParseSubjectError {
    fn severity(&self) -> Level {
        match self {
            Self::Strum(_) => Level::WARN,
            Self::Uuid(_) => Level::WARN,
            Self::InvalidSubjectFormat => Level::WARN,
        }
    }
}

impl From<UserId> for Subject {
    fn from(s: UserId) -> Self {
        Subject::User(s)
    }
}

impl From<CustomerId> for Subject {
    fn from(s: CustomerId) -> Self {
        Subject::Customer(s)
    }
}

impl std::fmt::Display for Subject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Subject::Customer(id) => {
                let uuid: uuid::Uuid = id.into();
                write!(f, "{}:{}", SubjectDiscriminants::from(self).as_ref(), uuid)
            }
            Subject::User(id) => {
                let uuid: uuid::Uuid = id.into();
                write!(f, "{}:{}", SubjectDiscriminants::from(self).as_ref(), uuid)
            }
            Subject::System(actor) => {
                write!(f, "system:{actor}")
            }
        }
    }
}

impl TryFrom<&Subject> for core_deposit::DepositAccountHolderId {
    type Error = &'static str;

    fn try_from(value: &Subject) -> Result<Self, Self::Error> {
        match value {
            Subject::Customer(id) => Ok(core_deposit::DepositAccountHolderId::from(*id)),
            _ => Err("Subject is not Customer"),
        }
    }
}

impl TryFrom<&Subject> for CustomerId {
    type Error = &'static str;

    fn try_from(value: &Subject) -> Result<Self, Self::Error> {
        match value {
            Subject::Customer(id) => Ok(*id),
            _ => Err("Subject is not Customer"),
        }
    }
}

impl TryFrom<&Subject> for UserId {
    type Error = &'static str;

    fn try_from(value: &Subject) -> Result<Self, Self::Error> {
        match value {
            Subject::User(id) => Ok(*id),
            _ => Err("Subject is not User"),
        }
    }
}

impl TryFrom<&Subject> for governance::CommitteeMemberId {
    type Error = &'static str;

    fn try_from(value: &Subject) -> Result<Self, Self::Error> {
        match value {
            Subject::User(id) => Ok(Self::from(*id)),
            _ => Err("Subject is not User"),
        }
    }
}
