type Account {
	id: UUID!
	name: String!
	amounts: AccountAmountsByCurrency!
}

type AccountAmountsByCurrency {
	btc: BtcAccountAmountsInPeriod!
	usd: UsdAccountAmountsInPeriod!
}

type AccountSet {
	id: UUID!
	name: String!
	amounts: AccountAmountsByCurrency!
	hasSubAccounts: Boolean!
}

type AccountSetAndSubAccounts {
	id: UUID!
	name: String!
	amounts: AccountAmountsByCurrency!
	subAccounts(first: Int!, after: String): AccountSetSubAccountConnection!
}

union AccountSetSubAccount = Account | AccountSet

type AccountSetSubAccountConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [AccountSetSubAccountEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [AccountSetSubAccount!]!
}

"""
An edge in a connection.
"""
type AccountSetSubAccountEdge {
	"""
	The item at the end of the edge
	"""
	node: AccountSetSubAccount!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

enum AccountStatus {
	ACTIVE
	INACTIVE
}

scalar AnnualRatePct

type AuditEntry {
	id: ID!
	object: String!
	action: String!
	authorized: Boolean!
	recordedAt: Timestamp!
	subject: Subject!
}

type AuditEntryConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [AuditEntryEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [AuditEntry!]!
}

"""
An edge in a connection.
"""
type AuditEntryEdge {
	"""
	The item at the end of the edge
	"""
	node: AuditEntry!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

type BalanceSheet {
	name: String!
	balance: AccountAmountsByCurrency!
	categories: [StatementCategory!]!
}


type BtcAccountAmounts {
	debit: Satoshis!
	credit: Satoshis!
	netDebit: SignedSatoshis!
	netCredit: SignedSatoshis!
}

type BtcAccountAmountsInPeriod {
	openingBalance: LayeredBtcAccountAmounts!
	closingBalance: LayeredBtcAccountAmounts!
	amount: LayeredBtcAccountAmounts!
}

scalar CVLPct

type CashFlowStatement {
	name: String!
	total: AccountAmountsByCurrency!
	categories: [StatementCategory!]!
}

type ChartOfAccounts {
	name: String!
	categories: [StatementCategory!]!
}

type Checking {
	settled: UsdCents!
	pending: UsdCents!
}

type Collateral {
	btcBalance: Satoshis!
}

enum CollateralAction {
	ADD
	REMOVE
}

input CollateralUpdateInput {
	loanId: UUID!
	collateral: Satoshis!
}

type CollateralUpdatePayload {
	loan: Loan!
}

type CollateralUpdated {
	satoshis: Satoshis!
	recordedAt: Timestamp!
	action: CollateralAction!
	txId: UUID!
}

input CollateralizationStateUpdateInput {
	loanId: UUID!
}

type CollateralizationStateUpdatePayload {
	loan: Loan!
}

type CollateralizationUpdated {
	state: LoanCollaterizationState!
	collateral: Satoshis!
	outstandingInterest: UsdCents!
	outstandingPrincipal: UsdCents!
	price: UsdCents!
	recordedAt: Timestamp!
}

input CreateTermsTemplateInput {
	name: String!
	annualRate: AnnualRatePct!
	interval: InterestInterval!
	duration: DurationInput!
	liquidationCvl: CVLPct!
	marginCallCvl: CVLPct!
	initialCvl: CVLPct!
}

type CreateTermsTemplatePayload {
	termsTemplate: TermsTemplate!
}

type CreditFacility {
	id: ID!
	creditFacilityId: UUID!
}

input CreditFacilityApproveInput {
	creditFacilityId: UUID!
}

type CreditFacilityApprovePayload {
	creditFacility: CreditFacility!
}

input CreditFacilityCreateInput {
	customerId: UUID!
	facility: UsdCents!
}

type CreditFacilityCreatePayload {
	creditFacility: CreditFacility!
}

type Customer {
	customerId: UUID!
	email: String!
	telegramId: String!
	status: AccountStatus!
	level: KycLevel!
	applicantId: String
	balance: CustomerBalance!
	loans: [Loan!]!
	deposits: [Deposit!]!
	withdrawals: [Withdrawal!]!
	audit: [AuditEntry!]!
}

type CustomerBalance {
	checking: Checking!
}

type CustomerConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [CustomerEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Customer!]!
}

input CustomerCreateInput {
	email: String!
	telegramId: String!
}

type CustomerCreatePayload {
	customer: Customer!
}

"""
An edge in a connection.
"""
type CustomerEdge {
	"""
	The item at the end of the edge
	"""
	node: Customer!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

input CustomerUpdateInput {
	customerId: UUID!
	telegramId: String!
}

type CustomerUpdatePayload {
	customer: Customer!
}

type Deposit {
	customerId: UUID!
	depositId: UUID!
	amount: UsdCents!
	reference: String!
	createdAt: Timestamp!
	customer: Customer
}

type DepositConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [DepositEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Deposit!]!
}

"""
An edge in a connection.
"""
type DepositEdge {
	"""
	The item at the end of the edge
	"""
	node: Deposit!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

input DepositRecordInput {
	customerId: UUID!
	amount: UsdCents!
	reference: String
}

type DepositRecordPayload {
	deposit: Deposit!
}

type Duration {
	period: Period!
	units: Int!
}

input DurationInput {
	period: Period!
	units: Int!
}



type IncrementalPayment {
	cents: UsdCents!
	recordedAt: Timestamp!
	txId: UUID!
}


type InterestAccrued {
	cents: UsdCents!
	recordedAt: Timestamp!
	txId: UUID!
}

type InterestIncome {
	usdBalance: UsdCents!
}

enum InterestInterval {
	END_OF_MONTH
}

enum KycLevel {
	ZERO
	ONE
	TWO
}

type LayeredBtcAccountAmounts {
	all: BtcAccountAmounts!
	settled: BtcAccountAmounts!
	pending: BtcAccountAmounts!
	encumbrance: BtcAccountAmounts!
}

type LayeredUsdAccountAmounts {
	all: UsdAccountAmounts!
	settled: UsdAccountAmounts!
	pending: UsdAccountAmounts!
	encumbrance: UsdAccountAmounts!
}

type Loan {
	id: ID!
	loanId: UUID!
	createdAt: Timestamp!
	approvedAt: Timestamp
	expiresAt: Timestamp
	loanTerms: TermValues!
	status: LoanStatus!
	collateral: Satoshis!
	principal: UsdCents!
	transactions: [LoanHistoryEntry!]!
	approvals: [LoanApproval!]!
	repaymentPlan: [LoanRepaymentInPlan!]!
	collateralizationState: LoanCollaterizationState!
	balance: LoanBalance!
	customer: Customer!
}

type LoanApproval {
	userId: UUID!
	approvedAt: Timestamp!
	user: User!
}

input LoanApproveInput {
	loanId: UUID!
}

type LoanApprovePayload {
	loan: Loan!
}

type LoanBalance {
	collateral: Collateral!
	outstanding: LoanOutstanding!
	interestIncurred: InterestIncome!
}

enum LoanCollaterizationState {
	FULLY_COLLATERALIZED
	UNDER_MARGIN_CALL_THRESHOLD
	UNDER_LIQUIDATION_THRESHOLD
	NO_COLLATERAL
}

type LoanConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [LoanEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Loan!]!
}

input LoanCreateInput {
	customerId: UUID!
	desiredPrincipal: UsdCents!
	loanTerms: TermsInput!
}

type LoanCreatePayload {
	loan: Loan!
}

"""
An edge in a connection.
"""
type LoanEdge {
	"""
	The item at the end of the edge
	"""
	node: Loan!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

union LoanHistoryEntry = IncrementalPayment | InterestAccrued | CollateralUpdated | LoanOrigination | CollateralizationUpdated

type LoanOrigination {
	cents: UsdCents!
	recordedAt: Timestamp!
	txId: UUID!
}

type LoanOutstanding {
	usdBalance: UsdCents!
}

input LoanPartialPaymentInput {
	loanId: UUID!
	amount: UsdCents!
}

type LoanPartialPaymentPayload {
	loan: Loan!
}

type LoanRepaymentInPlan {
	repaymentType: LoanRepaymentType!
	status: LoanRepaymentStatus!
	initial: UsdCents!
	outstanding: UsdCents!
	accrualAt: Timestamp!
	dueAt: Timestamp!
}

enum LoanRepaymentStatus {
	UPCOMING
	DUE
	OVERDUE
	PAID
}

enum LoanRepaymentType {
	PRINCIPAL
	INTEREST
}

enum LoanStatus {
	NEW
	ACTIVE
	CLOSED
}

type Mutation {
	shareholderEquityAdd(input: ShareholderEquityAddInput!): SuccessPayload!
	sumsubPermalinkCreate(input: SumsubPermalinkCreateInput!): SumsubPermalinkCreatePayload!
	loanCreate(input: LoanCreateInput!): LoanCreatePayload!
	loanApprove(input: LoanApproveInput!): LoanApprovePayload!
	loanPartialPayment(input: LoanPartialPaymentInput!): LoanPartialPaymentPayload!
	collateralUpdate(input: CollateralUpdateInput!): CollateralUpdatePayload!
	collateralizationStateUpdate(input: CollateralizationStateUpdateInput!): CollateralizationStateUpdatePayload!
	creditFacilityCreate(input: CreditFacilityCreateInput!): CreditFacilityCreatePayload!
	creditFacilityApprove(input: CreditFacilityApproveInput!): CreditFacilityApprovePayload!
	depositRecord(input: DepositRecordInput!): DepositRecordPayload!
	withdrawalInitiate(input: WithdrawalInitiateInput!): WithdrawalInitiatePayload!
	withdrawalConfirm(input: WithdrawalConfirmInput!): WithdrawalConfirmPayload!
	withdrawalCancel(input: WithdrawalCancelInput!): WithdrawalCancelPayload!
	customerCreate(input: CustomerCreateInput!): CustomerCreatePayload!
	customerUpdate(input: CustomerUpdateInput!): CustomerUpdatePayload!
	userCreate(input: UserCreateInput!): UserCreatePayload!
	userAssignRole(input: UserAssignRoleInput!): UserAssignRolePayload!
	userRevokeRole(input: UserRevokeRoleInput!): UserRevokeRolePayload!
	reportCreate: ReportCreatePayload!
	reportDownloadLinksGenerate(input: ReportDownloadLinksGenerateInput!): ReportDownloadLinksGeneratePayload!
	createTermsTemplate(input: CreateTermsTemplateInput!): CreateTermsTemplatePayload!
}

"""
Information about pagination in a connection
"""
type PageInfo {
	"""
	When paginating backwards, are there more items?
	"""
	hasPreviousPage: Boolean!
	"""
	When paginating forwards, are there more items?
	"""
	hasNextPage: Boolean!
	"""
	When paginating backwards, the cursor to continue.
	"""
	startCursor: String
	"""
	When paginating forwards, the cursor to continue.
	"""
	endCursor: String
}

enum Period {
	MONTHS
}

type ProfitAndLossStatement {
	name: String!
	net: AccountAmountsByCurrency!
	categories: [StatementCategory!]!
}

type Query {
	audit(first: Int!, after: String): AuditEntryConnection!
	loan(id: UUID!): Loan
	customer(id: UUID!): Customer
	customerByEmail(email: String!): Customer
	me: User!
	users: [User!]!
	termsTemplates: [TermsTemplate!]!
	user(id: UUID!): User
	customers(first: Int!, after: String): CustomerConnection!
	loans(first: Int!, after: String): LoanConnection!
	trialBalance(from: Timestamp!, until: Timestamp): TrialBalance
	offBalanceSheetTrialBalance(from: Timestamp!, until: Timestamp): TrialBalance
	chartOfAccounts: ChartOfAccounts
	offBalanceSheetChartOfAccounts: ChartOfAccounts
	balanceSheet(from: Timestamp!, until: Timestamp): BalanceSheet
	profitAndLossStatement(from: Timestamp!, until: Timestamp): ProfitAndLossStatement
	cashFlowStatement(from: Timestamp!, until: Timestamp): CashFlowStatement
	accountSet(accountSetId: UUID!, from: Timestamp!, until: Timestamp): AccountSetAndSubAccounts
	deposit(id: UUID!): Deposit
	deposits(first: Int!, after: String): DepositConnection!
	withdrawal(id: UUID!): Withdrawal
	withdrawals(first: Int!, after: String): WithdrawalConnection!
	realtimePrice: RealtimePrice!
	reports: [Report!]!
	report(id: UUID!): Report
}

type RealtimePrice {
	usdCentsPerBtc: UsdCents!
}

type Report {
	reportId: UUID!
	createdAt: Timestamp!
	lastError: String
	progress: ReportProgress!
}

type ReportCreatePayload {
	report: Report!
}

type ReportDownloadLink {
	reportName: String!
	url: String!
}

input ReportDownloadLinksGenerateInput {
	reportId: UUID!
}

type ReportDownloadLinksGeneratePayload {
	reportId: UUID!
	links: [ReportDownloadLink!]!
}

enum ReportProgress {
	RUNNING
	COMPLETE
}

enum Role {
	SUPERUSER
	ADMIN
	BANK_MANAGER
}

scalar Satoshis

input ShareholderEquityAddInput {
	amount: UsdCents!
	reference: String!
}

scalar SignedSatoshis

scalar SignedUsdCents

type StatementCategory {
	name: String!
	amounts: AccountAmountsByCurrency!
	accounts: [AccountSetSubAccount!]!
}


union Subject = User | Customer | System

type SuccessPayload {
	success: Boolean!
}

input SumsubPermalinkCreateInput {
	customerId: String!
}

type SumsubPermalinkCreatePayload {
	url: String!
}

type System {
	name: String!
}

type TermValues {
	annualRate: AnnualRatePct!
	interval: InterestInterval!
	duration: Duration!
	liquidationCvl: CVLPct!
	marginCallCvl: CVLPct!
	initialCvl: CVLPct!
}

input TermsInput {
	annualRate: AnnualRatePct!
	interval: InterestInterval!
	liquidationCvl: CVLPct!
	duration: DurationInput!
	marginCallCvl: CVLPct!
	initialCvl: CVLPct!
}

type TermsTemplate {
	id: ID!
	name: String!
	termsId: UUID!
	values: TermValues!
}

scalar Timestamp

type TrialBalance {
	name: String!
	total: AccountAmountsByCurrency!
	subAccounts: [AccountSetSubAccount!]!
}

scalar UUID

type UsdAccountAmounts {
	debit: UsdCents!
	credit: UsdCents!
	netDebit: SignedUsdCents!
	netCredit: SignedUsdCents!
}

type UsdAccountAmountsInPeriod {
	openingBalance: LayeredUsdAccountAmounts!
	closingBalance: LayeredUsdAccountAmounts!
	amount: LayeredUsdAccountAmounts!
}

scalar UsdCents

type User {
	userId: UUID!
	email: String!
	roles: [Role!]!
	visibleNavigationItems: VisibleNavigationItems!
}

input UserAssignRoleInput {
	id: UUID!
	role: Role!
}

type UserAssignRolePayload {
	user: User!
}

input UserCreateInput {
	email: String!
}

type UserCreatePayload {
	user: User!
}

input UserRevokeRoleInput {
	id: UUID!
	role: Role!
}

type UserRevokeRolePayload {
	user: User!
}

type VisibleNavigationItems {
	loan: Boolean!
	term: Boolean!
	user: Boolean!
	customer: Boolean!
	deposit: Boolean!
	withdraw: Boolean!
	audit: Boolean!
	financials: Boolean!
}

type Withdrawal {
	customerId: UUID!
	withdrawalId: UUID!
	amount: UsdCents!
	status: WithdrawalStatus!
	reference: String!
	createdAt: Timestamp!
	customer: Customer
}

input WithdrawalCancelInput {
	withdrawalId: UUID!
}

type WithdrawalCancelPayload {
	withdrawal: Withdrawal!
}

input WithdrawalConfirmInput {
	withdrawalId: UUID!
}

type WithdrawalConfirmPayload {
	withdrawal: Withdrawal!
}

type WithdrawalConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [WithdrawalEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Withdrawal!]!
}

"""
An edge in a connection.
"""
type WithdrawalEdge {
	"""
	The item at the end of the edge
	"""
	node: Withdrawal!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

input WithdrawalInitiateInput {
	customerId: UUID!
	amount: UsdCents!
	reference: String
}

type WithdrawalInitiatePayload {
	withdrawal: Withdrawal!
}

enum WithdrawalStatus {
	INITIATED
	CANCELLED
	CONFIRMED
}

directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
schema {
	query: Query
	mutation: Mutation
}
