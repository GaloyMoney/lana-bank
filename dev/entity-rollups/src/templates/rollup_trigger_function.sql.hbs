-- Auto-generated trigger function for {{entity_name}}
CREATE OR REPLACE FUNCTION {{rollup_table_name}}_trigger()
RETURNS TRIGGER AS $$
DECLARE
  event_type TEXT;
  current_row {{rollup_table_name}}%ROWTYPE;
  new_row {{rollup_table_name}}%ROWTYPE;
BEGIN
  event_type := NEW.event_type;

  -- Load the previous version if this isn't the first event
  IF NEW.sequence > 1 THEN
    SELECT * INTO current_row
    FROM {{rollup_table_name}}
    WHERE id = NEW.id AND version = NEW.sequence - 1;
  END IF;

  -- Validate event type is known
  IF event_type NOT IN ({{#each event_types}}'{{this.name}}'{{#unless @last}}, {{/unless}}{{/each}}) THEN
    RAISE EXCEPTION 'Unknown event type: %', event_type;
  END IF;

  -- Construct the new row based on event type
  new_row.id := NEW.id;
  new_row.version := NEW.sequence;
  new_row.created_at := COALESCE(current_row.created_at, NEW.recorded_at);
  new_row.modified_at := NEW.recorded_at;

  -- Initialize fields with default values if this is a new record
  IF current_row.id IS NULL THEN{{#each fields}}
    new_row.{{this.name}} := {{>field_init}};{{/each}}
  ELSE
    -- Default all fields to current values{{#each fields}}
    new_row.{{this.name}} := current_row.{{this.name}};{{/each}}
  END IF;

  -- Update only the fields that are modified by the specific event
  CASE event_type{{#each event_updates}}
    WHEN '{{this.name}}' THEN{{#each this.field_updates}}
      new_row.{{this.name}} := {{>field_update}};{{/each}}{{/each}}
  END CASE;

  INSERT INTO {{rollup_table_name}} (
    id,
    version,
    created_at,
    modified_at{{#each fields}},
    {{this.name}}{{/each}}
  )
  VALUES (
    new_row.id,
    new_row.version,
    new_row.created_at,
    new_row.modified_at{{#each fields}},
    new_row.{{this.name}}{{/each}}
  );

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;